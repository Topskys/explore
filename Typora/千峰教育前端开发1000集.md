DOM基本操作

js回到顶部案例

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		
		<style type="text/css">
			*{
				margin: 0;
				padding: 0;
				outline: none;
				box-sizing: border-box;/* 告诉浏览器:你想要设置的边框和内边距的值包含在总宽高内的 */
			}
			body{
				width: 100%;
				height: 2000px;
			}
			
			.header{
				width: 100%;
				height: 80px;
				display: flex;
				justify-content: center;
				align-items: center;
				font-size: 30px;
				color: black;
				background-color: #3498DB;
				transition: top .0.5s linear;
				
				position: fixed;
				top: 0%;
				left: 0;	
			}
			.toTop{
				width: 50px;
				height: 50px;
				background-color: red;
				font-size: 20px;
				text-align: center;
				line-height: 25px;
				color: white;
				
				position: fixed;
				bottom: 50px;
				right: 50px;
				display: none;
			}
			
		</style>
	</head>
	<body>
		<div class="header">顶部通栏</div>
		<div class="toTop">回到顶部</div>
		<script>
		var header=document.querySelector('.header')
		var toTop=document.querySelector('.toTop')
		//绑定滚动事件
		window.onscroll=function(){
			//获取浏览器卷去的高度
			var height=document.documentElement.scrollTop||document.body.scrollTop
			if(height>=300){
				//显示
				header.style.top='-80px'
				toTop.style.display='block'
			}else{
				//隐藏
				header.style.top='0px'
				toTop.style.display='none'
			}
		}
		//绑定点击事件
		toTop.onclick=function(){
			//让页面滚动回到顶部
			window.scrollTo({
				 top:0,
				 behavior:'smooth'
			})
		}
		</script>
	</body>
</html>
```

js全选

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		
		<style type="text/css">
			*{
				margin: 0;
				padding: 0;
				outline: none;
				box-sizing: border-box;/* 告诉浏览器:你想要设置的边框和内边距的值包含在总宽高内的 */
			}
			body{
				width: 100%;
				height: 2000px;
			}
			
			.box{
				width: 100px;
				padding: 20px;
				border: 1px solid pink;
				margin: 30px auto;
				border-radius: 5px;
			}
			hr{
				margin: 10px 0;
			}
			
		</style>
	</head>
	<body>
		<div class="box">
			全选：<input type="checkbox" /><br/>
			<hr >
			<input type="checkbox">选项一<br/>
			<input type="checkbox">选项二<br/>
			<input type="checkbox">选项三<br/>
			<input type="checkbox">选项四<br/>
		</div>
		
		<script>
		var allBtn=document.querySelector('input')//全选
		var checkboxs=document.querySelectorAll('input:nth-child(n+2)')//第2个后面所有的input
		//给全选绑定事件
		allBtn.onclick=function(){
			var type=allBtn.checked
			for(var i=0;i<checkboxs.length;i++){
				checkboxs[i].checked=type
			}
		}
		//给每一个选项绑定事件
		for(var i=0;i<checkboxs.length;i++){
			checkboxs[i].onclick=function(){
				var flag=true
				for(var j=0;j<checkboxs.length;j++){
					if(checkboxs[j].checked===false){
						flag=false
						break
					}
				}
				allBtn.checked=flag
			}
		}
		
		</script>
	</body>
</html>
```

js节点

```html
<script>
    //创建节点
    document.createElement("标签名称")
    //插入节点
    父节点.appendChild(子节点)
    父节点.insertBefore(要插入的子节点，那个一子节点的前面)
    //删除节点
    父节点.removeChild(子节点)
    节点.remove()
    //替换节点
    父节点.replaceChild(换上节点，换下节点)
    //克隆节点
    节点.cloneNode(是否克隆后代节点)
</script>
```

获取元素尺寸

```js
语法1：
元素.offsetHeight
元素.offsetWidth
获取：元素 内容+padding+border区域的尺寸
语法2：
元素.clientHeight
元素.clientWidth
获取：元素 内容+padding区域的尺寸
```

动态

```html
<!DOCTYPE html>
<html>
	<body>
		<table border="1" cellspacing="0">
			<thead>
				<tr>
					<th>ID</th>
					<th>姓名</th>
					<th>性别</th>
				</tr>
			</thead>
			<tbody>
				<!-- js 渲染 -->
			</tbody>
		</table>
		<script>
		var users=[
			{id:1,name:'小灰狼',age:18},
			{id:2,name:'小灰',age:20},
			{id:3,name:'小狼',age:26}
		]
		var tbody=document.querySelector('tbody')
		
		users.forEach(function(item){//数组中的每一个对象
			var tr=document.createElement('tr')//生成tr对象
			for(var key in item){
				var td=document.createElement('td')//生成td
				td.innerHTML=item[key]
				tr.appendChild(td)//把td插入tr内部
			}
			tbody.appendChild(tr)//把tr插入tbody内部
		})
		</script>
	</body>
</html>
```

js跟随鼠标移动案例

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		
		<style type="text/css">
			*{
				margin: 0;
				padding: 0;
				outline: none;
				box-sizing: border-box;/* 告诉浏览器:你想要设置的边框和内边距的值包含在总宽高内的 */
			}
			img{
				width: 50px;
				height: 50px;
				
				position: fixed;
				left: 0;
				top:0;
			}
		</style>
	</head>
	<body>
		<img src="../img/2.jpg" alt="">
		<script>
		var imgBox=document.querySelector('img')
		document.onmousemove=function(e){
			var x=e.clientX
			var y=e.clientY
			imgBox.style.left=x+5+'px'
			imgBox.style.top=y+5+'px'
		}
		</script>
	</body>
</html>
```

js事件传播、阻止事件传播、事件委托




```html
	<style type="text/css">
		*{
			margin: 0;
			padding: 0;
			outline: none;
			box-sizing: border-box;/* 告诉浏览器:你想要设置的边框和内边距的值包含在总宽高内的 */
		}
		
		.outer{
			width: 150px;
			height: 150px;
			background-color: lightgray;
		}
		.outer .center{
			width: 100px;
			height: 100px;
			background-color: pink;
		}
		.outer .center .inner{
			width: 50px;
			height: 50px;
			background-color: palevioletred;
		}
	</style>
</head>
<body>
	<div class="outer">outer
		<div class="center">center
			<div class="inner">inner</div>
		</div>
	</div>
	<script>
	var outer=document.querySelector('.outer')
	var center=document.querySelector('.center')
	var inner=document.querySelector('.inner')
	//事件传播
	outer.onclick=function(){console.log('outer')}
	center.onclick=function(){console.log('cenetr')}
	inner.onclick=function(e){
		//阻止事件传播
		e.stopPropagation()
		console.log('inner')}
	</script>
</body>
```

```html
	<style type="text/css">
		*{
			margin: 0;
			padding: 0;
			outline: none;
			box-sizing: border-box;/* 告诉浏览器:你想要设置的边框和内边距的值包含在总宽高内的 */
		}
		
		ul{
			width: 500px;
			height: 500px;
			background-color: royalblue;
			display: flex;
			justify-content: center;
			align-items: center;
			font-size: 20px;
			cursor: pointer;
		}
		ul>li{
			width: 50px;
			height: 50px;
			text-align: center;
			line-height: 50px;
			list-style: none;
			background-color: pink;
			margin-right: 50px;
		}
	</style>
</head>
<body>
	<ul>
		<li>1</li>
		<li>2</li>
		<li>3</li>
	</ul>
	<script>
	//li事件委托ul
	var ul=document.querySelector('ul')	
	ul.onclick=function(e){
		if(e.target.tagName==='LI'){
			console.log("li事件")
		}
		if(e.target.tagName==='UL'){
			console.log("ul事件")
		}
	}
	</script>
</body>
```
js轮播图


```html
	<style type="text/css">
		*{
			margin: 0;
			padding: 0;
			outline: none;
			box-sizing: border-box;/* 告诉浏览器:你想要设置的边框和内边距的值包含在总宽高内的 */
		}
		body{
			display: flex;
			justify-content: center;
			align-items: center;
		}
		
		ul,ol,li{
			list-style: none;
		}
		img{
			width: 100%;
			height: 100%;
			display: block;
		}
		.banner{
			width: 1000px;
			height: 500px;
			position: relative;
			margin: 50px 0;
		}
		.banner>ul{
			width: 100%;
			height: 100%;
			position: relative;
		}
		.banner>ul>li{
			width: 100%;
			height: 100%;
			position: absolute;
			left: 0;
			top: 0;
			
			opacity: 0;
			
			transition: opacity .5s linear;
		}
		.banner>ul>li.active{
			opacity: 1;
		}
		.banner>ol{
			width: 200px;
			height: 30px;
			position: absolute;
			left: 30px;
			bottom: 30px;
			background-color: rgba(0,0,0,.5);
			
			display: flex;
			justify-content: space-around;
			align-items: center;
			border-radius: 15px;
		}
		.banner>ol>li{
			width: 20px;
			height: 20px;
			background-color: #fff;
			border-radius: 50%;
			cursor: pointer;
		}
		.banner>ol>li.active{
			background-color: orange;
		}
		
		.banner>div{
			width: 40px;
			height: 60px;
			position: absolute;
			top: 50%;
			transform: translateY(-50%);
			background-color: rgba(0,0,0,0.5);
			
			/* 里面文本居中 */
			display: flex;
			justify-content: center;
			align-items: center;
			color: #fff;
			font-size: 30px;
		}
		.banner>div.left{
			left: 0;
		}
		.banner>div.right{
			right: 0;
		}
	</style>
</head>
<body>
	<div class="banner">
		<ul class="imgBox"><!-- ul.imgBox>li*4>img[src=./imgs/0$.jpg] -->
			<li class="active"><img src="../img/2.jpg" alt=""></li>
			<li><img src="../img/3.png" alt=""></li>
			<li><img src="../img/4.jpg" alt=""></li>
			<li><img src="../img/5.jpg" alt=""></li>
		</ul>
		<ol>
			<li data-name="point"  data-i="0" class="active"></li>
			<li data-name="point"  data-i="1"></li>
			<li data-name="point"  data-i="2"></li>
			<li data-name="point"  data-i="3"></li>
		</ol>
		<div class="left">&lt;</div>
		<div class="right">&gt;</div>
	</div>
	
	<script>
	var imgs=document.querySelectorAll('ul>li')
	var points=document.querySelectorAll('ol>li')
	var banner=document.querySelector('.banner')
	var index=0
	
	function change(type){
		//让这一张消失
		imgs[index].className=''
		points[index].className=''
		//根据type传递参数判断index值
		if(type===true){
			index++
		}else if(type===false){
			index--
		}else{
			index=type
		}
		//判断index边界值
		if(index>=imgs.length){
			index=0
		}
		if (index<0){
			index=imgs.length-1
		}
		//让改变这一张显示出来
		imgs[index].className='active'
		points[index].className='active'
	}
	//给盒子banner绑定点击事件
	banner.onclick=function(e){
        //事件委托
		if(e.target.className==='left'){
			change(false)
		}
		if(e.target.className==='right'){
			change(true)
		}
		if(e.target.dataset.name==='point'){
			var i=e.target.dataset.i-0
			change(i)
		}
	}
	setInterval(function(){
		change(true)
	},5000)
	</script>
</body>
```
工厂函数批量创建对象

```js
function createObj(name,age){
    var obj={}//手动创建一个对象
    
    //手动添加属性
    obj.name=name
    obj.age=age
    obj.sayHi=function(){ console.log('sayHi')}
    
    return obj//手动返回对象
}
//调用工厂模式函数
var obj1=createObj('Jack',18)
```

构造函数自动创建对象

```html
function CreateObj(name,age){
    //this指向当前实例obj1
    this.name=name
    this.age=age
    this.sayHi=function(){ console.log('sayHi')}
    //不要写return
}
var obj1=new CreateObj('Jack',18)//构造函数调用时要与new连用(this)
obj2.sayHi和obj1.sayhi函数一模一样，占用内存，需要出掉一个func()
解决：让objx和obj1使用同一个func()函数
原型：构造函数自带属性prototype是一个对象数据类型；每个对象自带一个属性__proto__,指向所属构造函数的prototype；当你访问对象成员时，先在自己身上查找，if没有，自动去到__proto__上查找。

function Person() {}
Person.prototype.name='Ruo'//添加成员

var p1=new Person()
console.log(p1.__proto__===Person.prototype)//true
console.log(p1.__proto__)
console.log(p1.a)//访问p1的a成员if p1.a is null->proto->prototype
console.log(p2.__proto__===Person.prototype)//true
问题1：实例对象身上的 __proto__ 指向谁 ？
=> 指向所属构造函数的 prototype
=> p1 所属的构造函数是 Person
=> p1.__proto__ 指向 Person.prototype
问题2：Person.prototype 的___proto__ 指向谁 ?
=> Person.prototype 所属的构造函数是谁
=> 因为 Perosn.prototype 是一个对象数据类型(Object)
=> 在 JS 内所有的 Object 数据类型都是属于 Object 这个内置构造函数
=> Person.prototype 是属于 Object 这个内置构造函数的
=> Person.prototype 的 __proto_  指向 Object.prototype
问题3：Person 的 __proto__ 指向谁 ?
=> Person 是一个函数，函数本身也是一个对象，就会有 __proto_
=> 在 JS 内，所有的函数都是属于内置构造函数 Function 的实例
=> Person.__proto__ 指向 Function.prototype
问题4：Object.prototype 的 __proto__ 指向谁 ?
=> Object.prototype 是一个对象数据类型，只要是对象，都是数据 Object 这个内置构造函数的
注意：Object.prototype 在 JS 内叫做顶级原型，不在有 __proto__ 了 
=> Object.prototype 的 __proto_指向 null
问题5：Object 的 __proto__ 指向谁 ?
=> Object 是内一个内置构造函数，同时也是一个函数， 同时也是一个对象
=>  在js内，所有的函数都是属于内置构造function的实例
=> Object也是Function的实例
=> Object.__proto__指向Function.prototype
问题6：Function.prototype的__proto__ 指向谁 ?
=> function.prototype也是一个数据类型
=> 只要是对象数据类型都是Object的实例
=> Function.prototype的__proto__指向object.prototype
问题7： Function 的 __proto__ 指向谁 ?
=> function是内一个内置构造函数，同时也是一个函数
=>  在js内，所有的函数都是属于内置构造function的实例
=>function自己是自己的实例构造函数
=>function自己是自己的实例对象
=>function所属的构造函数是function

原型链：为了访问对象成员，用__proto__串联起来的对象链状结构，每一个对象数据类型，都有一个属于自己的原型链。

对象访问机制：访问对象成员-->自己身上没有-->__proto__也没有-->再去__proto__查找，直到Object.prototype都没有，那么返回undefined

<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>

		<style type="text/css">
			* {
				margin: 0;
				padding: 0;
				outline: none;
				box-sizing: border-box;
				/* 告诉浏览器:你想要设置的边框和内边距的值包含在总宽高内的 */
			}

			/* body{
				display: flex;
				justify-content: center;
				align-items: center;
			} */

			ul,
			ol,
			li {
				list-style: none;
			}

			.tab {
				width: 600px;
				height: 400px;
				border: 10px solid #333;
				margin: 50px auto;
				display: flex;
				flex-direction: column; //竖向
			}
			ul {
				height: 60px;
				display: flex;
			}
			ul>li {
				flex: 1;
				display: flex;
				justify-content: center;
				align-items: center;
				font-size: 40px;
				color: #fff;
				background-color: skyblue;
				cursor: pointer;
			}
			ul>li.active {
				background-color: orange;
			}

			ol {
				flex: 1;
				position: relative;
			}
			ol>li{
				position: absolute;
				left: 0;
				top: 0;
				width: 100%;
				height: 100%;
				font-size: 100px;
				color: #fff;
				background-color: purple;
				
				/* //让3水平垂直居中 */
				display: none;
				justify-content: center;
				align-items: center;
			}
			ol>li.active{
				display: flex;
			}
		</style>
	</head>
	<body>
		<div class="tab" id="box">
			<ul>
				<li class="active">1</li>
				<li>2</li>
				<li>3</li>

			</ul>
			<ol>
				<li class="active">1</li>
				<li>2</li>
				<li>3</li>
			</ol>
		</div>
		<!-- 简单版面向对象选项卡 -->
		<script type="text/javascript">
			// 构造函数
			function Tabs(ele){
				//范围
				this.ele=document.querySelector(ele)
				//在范围内寻找所有可以点击的盒子
				this.btns=this.ele.querySelectorAll('ul>li')
				//在范围内寻找所有可以显示的盒子
				this.tabs=this.ele.querySelectorAll('ol>li')
			}
			
			// 原型方法
			Tabs.prototype.change=function(){
				//提前保存this
				var _this=this
				
				for(var i=0;i<this.btns.length;i++){
					//提前保存索引
					this.btns[i].setAttribute('index',i)
					this.btns[i].addEventListener('click',function(){
						//console.log('我被点击了')
						//console.log(this)
						//when你访问_this，其实是访问变量
						//自己作用域没有就会去上一级作用域查找
						for(var j=0;j<_this.btns.length;j++){
							_this.btns[j].className=''
							_this.tabs[j].className=''
						}
						
						//当前点击这个li有active类名
						this.className='active'
						//让实例身上的tabs里面索引对应一个li有active类名
						//拿到当前li身上保存的索引
						var index=this.getAttribute('index')-0
						_this.tabs[index].className='active'
					})
				}
			}
			
			var t=new Tabs('#box')
			t.change()
			console.log(t)
		</script>
	</body>
</html>
```

ES6箭头函数

```js
1、省略function&()
var f1=function(){console.log('f1')}
f1()
var f2=()=>{console.log('没有形参')}
var f3=a=>{console.log('有一个形参',a)}
f3(100)
var f4=(a,b)=>{console.log('有两个形参',a,b)}//有两个形参以上需要加挂号
f4(100,200)
2、省略{}&return
var f1=(a,b)=>{return a+b}
var f1=(a,b)=>a+b
3、箭头函数没有arguments
4、没有this
var obj={
    f1:function (){console.log(this)}//this指向obj
    f2:()=>{console.log(this)}//外部作用域的this
}
```

ES6解构赋值

```js
before：
let arr=['hello','world']
let a=arr[0]
let b=arr[1]
//解构赋值
let [a,b]=['hello','world']
//解构对象{}
var obj={name:'Jack',age:18}
//定义变量name,age获取obj内name,age成员的值
var {name,age}=obj
console.log(name)
console.log(age)
//别名
var {age:a}=obj===var a=obj.age#a为别名
console.log(a)
```

ES6模板字符串

```js
before:
var str=''//""
//反单引号``
1、可以换行书写
var s1='yy'
var s2=`y
y`
2、need变量时，直接书写${变量}
var age=18
var age1=`my name is yy, I'm ${age}.`
console.log(age1)
```

ES6的展开运算符...

```js
作用：展开数组的[]或者展开对象的{}
console.log(1,2,3,4)
var arr=[1,2,3,4]
console.log(...arr)===console.log(1,2,3,4)
1、合并数组
var arr1=[1,2]
var arr2=[3,4]
var arr3=[5,6]
var arr4=[...arr1,...arr2,...arr3]
2、给函数传递参数
var arr1=[1,2,3,4,5,6,7,8,9,10]
var max=Math.max(...arr1)//...否则Nan
3、展开对象（去{}）
var obj={name:'Jack',age:18}
var obj2={
    gender:'男',
    ...obj
}
```

ES6类语法

```js
function Person(name,age){
    this.name=name
    this.age=age
}
Person.prototype.sayHi=function(){console.log('sayHi')}
//调用
var p1=new Person('Jack',18)
p1.sayHi()

//类书写
class Person{
    constructor(name,age){
        this.name=name
        this.age=age
    }
    static a=100//静态属性
    //直接书写原型上的方法
    static sayHi () {console.log('sayHi')}//静态
}
var p1=new Person('aa',20)//必须与new连用
p1.sayHi()或Person.sayhi()
```

前后端交互

```js
前端--服务器(后端)--数据库
获得后端接口文档
Ajax：
var xhr=new XMLHttpRequest()//创建ajax对象
xhr.open('get/post','xxx',true)//配置本次请求信息(请求方式，请求地址，是否异步)
xhr.onload=function(){ 
    //when后端返回的是json格式字符串，需要单独的解析
    JSON.parse(xhr.responseText)
    console.log(xhr.responseText)//后端返回的信息
    console.log('请求完成')
}//注册请求完成事件
xhr.send()//把请求发送出去

get:
偏向获取的语义化
参数是查询字符串
大小限制约2KB
'参数位置在地址后面?参数1=?&参数2=?'

post:
偏向提交的语义化
参数格式多样，但需要特殊说明(如：xhr.setRequestHeader('content-type',传递参数的格式))
理论没有限制大小
参数位置在请求体内//xhr.send('参数1=value1&参数2=value2')

//登录实例
var loginForm=document.querySelector('form')
var nameInp=document.querySelector('.username')
var pwdInp=document.querySelector('.password')
var errBox=document.querySelector('.error')
loginForm.onsubmit=function(e){
    e.preventDefault()//阻止表单自动提交行为
    var name=nameInp.value//账户
    var pwd=pwdInp.value//密码
    
    if (!name||!pwd) return alert('请完整填写表单')
    
    var xhr=new XMLHttpRequest()//创建ajax对象
    xhr.open('POST','http://',true)
    xhr.onload=function(){  
        var res=JSON.parse(xhr.responseText)
        //code or massage判断登录是否成功
        if(res.code===0){
            errBox.style.display='block'
        }else{
            //登陆成功
            window.location.href='./home.html'
        }
        
    }//注册请求完成事件
    xhr.setRequestheader('content-type','application/x-www--form-urlencoded')//post特殊说明
    xhr.send('username='+name+'&password='+pwd)//把请求发送出去
}
```

jQuery

对DOM操作进行封装：

```js
· 获取DOM节点 
· 获取节点尺寸 
· 节点动画操作
· 操作节点文本
· 获取节点偏移量 
· ajax 封装
· 操作节点样式 
· 操作节点事件
· 操作节点类名
· 操作节点属性

1、jQuery的选择器
$('选择器')
//结构选择器$('li:nth-child(odd偶数li/even奇数的li')
//$('选择器').筛选器()
//筛选器：first()、next()、perv()、parent()、siblings()兄弟元素、last()、nextAll()、prevAll()、parents()、find()找到所有后代元素、eq(索引数字)...

2、jQuery操作文本内容
html('yy')===js中的innerHTML='yy'
text('yy')===js中的innerText='yy'
val()===js中的value//$('input').val('yy')

3、jQuery操作类名
addClass('e')
removeClass('e')
toggleClass('box')//切换类名

4、操作元素样式
$('div').css('width')//获取行内样式，也可以获取非行内样式
$('div').css('width','300px')/$('div').css('width',300)//设置div的width当px时可以省略
$('div').css({
    width:260,
    height:260,
    opacity:0.68,
    'background-color':'purpl'
})//批量设置

5、操作元素属性
attr()//获取:取自定义属性，所操会示素上；设置:元素.attr(属性，值)
removeAttr()
prop()//只获取prop设置的属性；设置原生属性会响应在标签，prop自定属性，会响应在元素对象身上
removeProp()//只能删除由prop自定义之属

6、获取元素尺寸
width()
height()
innerwidth()
innerheight()
outerwidth()//在outerwh(true)表示包含margin值
outerheight()

7、操作元素偏移量
offset()//get素对于左上之位，返值为对象数据类型{top:y,left:x}
position()//if u 设置右底会自动换成left&top值
```

jQuery事件绑定

```js
1、on()
元素集合.on('eventType',处理函数)
元素集合.on('eventType',选择器,处理函数)//委托事件
元素集合.on({'Type1':处理函数,'Type2':处理函数2})//批量，不可委托

2、one()//只能执行一次

3、hover()
元素集合.hover(移入处理函数,移出处理函数)//不可委托，少一参则移入出都触发

4、常用事件函数
$('div').click/mouseover()/mouseout()/change()(function(){})
```

jQuery事件解绑与触发

```js
1、off()事件解绑
元素集合.off(type)
元素集合.off(type,要解绑的事件处理函数)

2、trigger()事件触发
元素集合.trigger(type)
setInterval(function(){$('div').trigger('click')},1000)
```

jQuery动画

```js
1、基本动画
show()//显示
hide()//隐藏
toggle()//切换
$('div').show(1000,'linear',function(){})

2、折叠动画
slideDown()
slideUp()
slideToggle()

3、渐隐渐现动画
fadeIn()
fadeOut()
fadeToggle()
fadeTo()//运动时间,指定的透明度，运动曲线，运动结束的回调函数
//以上均有运动时间、运动曲线、运动结束的回调函数三个参数

4、综合动画
animate(运动样式，时间，曲线，结束回调函数)
//color、transform相关样式不可动
$('buttom').click(function(){
    $('div').animate({
        width:500px,
        height:600
    },1000,'linear',function(){})
})

5、结束动画
stop()
finish()
$('buttom').click(function(){
    $('div').finish().toggle(1000)//每一次触发前把前面动画瞬间完成，只执行本次最新的动画
})
```

jQuery的ajax请求

```js
$.ajax({
    url:address,
    method:'get/post',//选填get（default）
    data:'',//带给后端数据，选填
    async:,//是否异步，true（default）,选填
    success:,//请求完成回调函数，选填
    error://选填，请求失败回调函数
})

$.ajax({
    url:address,
    method:'get',
    data:{name:'yy',age:18},//对象数据类型
    success:function(res){
        //res后端相应结果
    }
})


```









**Vue.js**

```html

		<style type="text/css">
			.red {
				background-color: red;
			}

			.yellow {
				background-color: yellow;
			}

			.active {
				background-color: green;
			}

			.aa {}

			.bb {}

			.cc {}




			#overlay {
				background: rgba(0, 0, 0, 0.6);
				width: 100%;
				margin: 0 auto;
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;

			}

			#center {
				background-color: #fff;
				border-radius: 5px;
				padding-top: 15px;
				padding-left: 30px;
				padding-bottom: 15px;
				width: 290px;
				height: 160px;
				position: fixed;
				margin: auto;
				left: 0;
				right: 0;
				top: 0;
				bottom: 0;
			}


			.shoppingCart>li {
				display: flex;
				justify-content: space-around;
				padding: 10px;
			}

			li>img {
				width: 100px;
				height: 100px;
				object-fit: cover;
			}
		</style>


	<body>

		<!-- :表示动态class =v-bind:-->
		<!-- <div id="app1" :class="whichColor">
		<img :src="imgPath" alt=""> -->

		<!-- 变量 -->
		<!-- {{var_value}} -->

		<!-- v-show、v-if 指令 -->
		<!-- <div v-show="isShow">我是动态显示和隐藏</div>
		<div v-if="isCreated">我是动态创建和删除</div> -->

		<!-- v-model双向绑定表单指令 -->


		<!-- v-for 遍历列表渲染指令 -->
		<!-- <ul>
			<li v-for="(item,index) in list">{{item}}-{{index}} </li>
			<li v-for="i in list">{{i}}</li>
			
		</ul> -->

		<!-- v-html渲染页面 -->
		<!-- <div v-html="mytext"></div>
		
		<ul>
			<li v-for="(data,index) in datalist" class="current===index? 
			'active':''" @click="clickData(index)">
			{{data}}--{{index}}
			</li>
		</ul> -->



		<!-- 动态切换class -->
		<!-- <div :class="classobj">动态切换class--对象</div>
		<div :class="classarr">动态切换class--数组</div> -->


		<!-- 动态切换style -->
		<!-- <div :style="styleobj">动态切换style--对象</div>
		<div :style="stylearr">动态切换style--数组</div> -->

		<!-- @click="change()"=v-on:click="change()"绑定点击事件 -->

		<!-- <button type="button" @click="change()">change</button>
    </div> -->


		<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>

		<!-- <script>
	var app1=new Vue({
		el:"#app1",
		data:{
			whichColor:'red',
			imgPath:"",
			var_value:1000,
			isShow:true,//显示
			isCreated:true,
			list:["a","b","c","d","e","f","g"],
			mytext:"<b>你好，Vue</b>",//加粗
			datalist:["首页","列表","我的"],
			current:0,
			classobj:{
				aa:true,//显示
				bb:false,
				cc:false,
				//Vue.set(app1.classobj,"dd",true)添加.dd
			},
			//Vue.set(app1.styleobj."font-size","30px")
			classarr:["ee","ff","gg"],//app1.classarr.push("hh")
			styleobj:{
				backgroundColor:"green"
			},
			stylearr:[{backgroundColor:"blue"}]
		},
		methods:{
			change(){
				this.whichColor="yellow"
				this.var_value=20
				this.isShow=!this.isShow
				this.isCreated=!this.isCreated
			},
			clickData(index){
				console.log(index)
				console.log(this.current)
				this.current=index
				
			},
			
			
		}
	})
	
	
	</script> -->

		<!-- 第一种模糊查询 -->
		<!-- input change事件区别:change失去焦点才触发 ，v-model监听-->
		<!-- <div class="box">
		
		<input type="text" @input="handleInput" v-model="Vuetext">
		<ul>
			<li v-for="i in datalist" :key>{{i}}</li>
		</ul>
	</div>
	<script type="text/javascript">
		var vm1=new Vue({
			el:".box",
			data:{
				Vuetext:"",
				datalist:["abcd","bab","cqc","ddc","eace"],
				originlist:["abcd","bab","cqc","ddc","eace"]
			},
			methods:{
				handleInput(){
					this.datalist=this.originlist.filter(item=>item.includes(this.Vuetext))
				}
			}
		})
	</script> -->

		<!-- 第二种模糊查询 -->
		<!-- input change事件区别:change失去焦点才触发 ，v-model监听-->
		<!-- <div class="box">
		
		<input type="text" v-model="Vuetext">
		<ul>
			<li v-for="i in search()" :key="i">{{i}}</li>
		</ul>
	</div>
	<script type="text/javascript">
		var vm2=new Vue({
			el:".box",
			data:{
				Vuetext:"",
				datalist:["abcd","bab","cqc","ddc","eace"]
			},
			methods:{
				search(){
					return this.datalist.filter(item=>item.includes(this.Vuetext))
				}
			}
		})
	</script> -->

		<!-- evt.target.value，可以获取input输入框的内容 -->
		<!-- <div class="box">
		{{count}}
		
		<button @click="add1($event,1,2,3)">add1-函数表达式(传参)</button>
		<button @click="add2">add2-函数名</button>
		<button @click="count++">add3-表达式</button>
		<input type="text" @input="VueInput">
	</div>
	<script>
	var app2=new Vue({
		el:".box",
		data:{
			count:1
		},
		methods:{
			add1(evt,a,b,c){ 
				this.count++
				console.log(evt.target,a,b,c)
			},
			add2(evt){
				this.count--
				console.log(evt.target)
			},
			VueInput(evt){
				console.log("input",evt.target.value)
			}
		}
	})
	</script> -->

		<!-- 阻止事件传播，修饰符 -->
		<!-- <ul @click.self="ulClick" id="ulself">
		<li @click.stop="liClick1">li11</li>
		<li @click="liClick2">li22</li>
		<li>li3</li>
	</ul>
	<script type="text/javascript">
		new Vue({
			el:"#ulself",
			methods:{
				ulClick(){
					console.log("ul")
				},
				liClick1(){
					console.log("li1")
				},
				liClick2(){
					console.log("li2")
				}
			}
		})
	</script> -->


		<!-- 模态框,修饰符 -->
		<!-- div id="center" @click.stop防止在input输入时被
	div id="overlay" v-show="isShow" @click="isShow=false"误关闭窗口
	 （冒泡事件传播）或者在 id="overlay" v-show="isShow" @click.self="isShow=false"-->
		<!-- <div id="box1">
		<button @click="isShow=true">show</button>
		
		<div id="overlay" v-show="isShow" @click.self="isShow=false">
			<div id="center" >
				<div>账户：<input type="text"></div>
				<div>密码：<input type="password"></div>
				<div><button type="button">登录</button></div>
			</div>
		</div>
	</div> -->

		<!-- <a href="www.baidu.com" @click.prevent>跳转（prevent阻止默认行为， 修饰符）</a>-->


		<!-- 按键键值，修饰符 -->
		<!-- @keyup.enter="keyupCode"按enter键才触发，.enter.up也可以组合触发或者.数值 -->
		<!-- 常见修饰符：esc、up、down、left、right、space、ctrl、shift、delete、lazy、number -->
		<!-- <input type="text" id="input2" @keyup.enter="keyupCode">
	<script>
	var app3=new Vue({
		el:"#input2",
		methods:{
			keyupCode(evt){
				console.log("键值：",evt.keyCode)
			}
		}
	})
	</script> -->



		<!-- 表单控键绑定，双向绑定v-model（mvvm），要有value否则全选-->
		<!-- <div id="box">
			{{mytext}}
			<textarea v-model="mytext"></textarea>
			<div>
				<div>用户：<input v-model="mytext"></div>
				<input type="checkbox" v-model="isRemember">记住我

				<button @click="login">登录</button>
			</div>

			<div>
				<h2>注册页面--兴趣爱好</h2>
				<input type="checkbox" v-model="checkList" value="vue">vue
				<input type="checkbox" v-model="checkList" value="react">react
				<input type="checkbox" v-model="checkList" value="sapp">小程序
				{{checkList}}
			</div>
			<div>
				<input type="radio" v-model="select" value="man">男
				<input type="radio" v-model="select" value="lady">女
				{{select}}
			</div>
		</div>
		<script>
			var app4 = new Vue({
				el: "#box",
				data: {
					mytext: localStorage.getItem("username"), //试试获取username
					isRemember: true, //勾上
					checkList: [], //注册多选，勾选上的数组数据。勾上vue则checkList["vue"]
					select: "man"
				},
				methods: {
					login() {
						if (this.isRemember) {
							localStorage.setItem("username", this.mytext)
						}
					}
				}
			})
		</script>-->

		<!-- 购物车css -->
		<style type="text/css">
			
			.shoppingCart>li {
				display: flex;
				justify-content: space-around;
				padding: 10px;
			}

			li>img {
				width: 100px;
				height: 100px;
				object-fit: cover;
			}
		</style>
			<body>
		<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>

		<!-- 购物车 -->
		<div class="shoppingCart">
			<input type="checkbox" v-model="isAll" @change="allChecked">全选
			<ul>
				<li v-for="(item,index) in datalist" :key="item.id">
					<input type="checkbox" v-model="checklist" :value="item" @change="itemChecked">
					<img :src="item.pic">
					<div>
						<div>{{item.name}}</div>
						<div style="color: red;">￥ {{item.price}}</div>
					</div>
					<div>
						<button @click="item.number--" :disabled="item.number===1">-</button>
						<span>{{item.number}}</span>
						<button @click="item.number++" :disabled="item.number===item.limit">+</button>
					</div>
					<div>
						<button @click="delProduct(index,item.id)">删除</button>
					</div>
				</li>
			</ul>
			<div>总金额：{{sumPrice()}}</div>
			{{checklist}}
		</div>
		<script src="https://unpkg.com/vue@next"></script>
		<script type="text/javascript">
			var obj = {
				data() {
					return {
						isAll:false,
						datalist: [{
								name: "商品1",
								price: 10,
								number: 1,
								id: 1,
								limit: 5, //限购
								pic: "../../img/2.jpg"
							},
							{
								name: "商品2",
								price: 130,
								number: 1,
								id: 2,
								limit: 5, //限购
								pic: '../../img/3.png'
							},
							{
								name: "商品3",
								price: 1467,
								number: 1,
								id: 3,
								limit: 5, //限购
								pic: "../../img/4.jpg"
							}
						],
						checklist: []
					}
				},
				methods: {
					allChecked(){//全选
						if(this.isAll){
							this.checklist=this.datalist
						}else{
							this.checklist=[]
						}
					},
					itemChecked(){//单选时
						if(this.checklist.length===this.datalist.length){
							this.isAll=true
						}else{
							this.isAll=false
						}
					},
					sumPrice() {//总金额
						var total = 0
						this.checklist.forEach(item => {
							total += item.price * item.number
						})
						return total
					},
					delProduct(index,id) {//删除
						this.datalist.splice(index,1)//从第几个索引值开始删除
						this.checklist=this.checklist.filter(item=>item.id!==id)//filter()过滤 删除
						//同步一哈状态
						this.itemChecked()
					}
				},
			}
			Vue.createApp(obj).mount(".shoppingCart")
		</script>
	</body>
        
        
<--去除输入框输入文本首尾空格,修饰符-->
<input type="text" v-model.trim="username">
<--去除输入框输入文本保留数字类型,修饰符-->
<input type="number" v-model.number="age">
    
    
<-- 计算属性 -->
<!-- 计算属性，防止过重，难以维护，负责逻辑放在计算属性中来写 -->
		<!-- 首字母大写t+后续字母opsky -->
		<div id="box">
			<!-- 方法一：属性模块 -->
			{{name.substring(0,1).toUpperCase()+name.substring(1)}}
			<!-- 方法二：计算属性，推荐 （计算属性有缓存，多次条用不会重复执行函数，而方法会多次执行函数没有缓存）-->
			{{computedName}}
			<!-- 方法三：函数 -->
			{{methodsName()}}
		</div>
		
		<script src="https://unpkg.com/vue@next"></script>
		<script type="text/javascript">
			var obj = {
				data() {
					return{
						name:"topsky"
					}
				},
				//计算的
				computed:{
					computedName(){
						return this.name.substring(0,1).toUpperCase()+this.name.substring(1)
					}
				},
				//方法
				methods:{
					methodsName(){
						return this.name.substring(0,1).toUpperCase()+this.name.substring(1)
					}
				}
			}
			Vue.createApp(obj).mount("#box")
		</script>
    
    
    
    <!-- 计算属性-改造案例1 -->
		<!-- 第一种模糊查询 -->
		<!-- input change事件区别:change失去焦点才触发 ，v-model监听-->
		<div id="box">
			<input type="text"  v-model="Vuetext">
			<ul>
				<li v-for="i in computedlist" :key>{{i}}</li>
			</ul>
		</div>
		<script type="text/javascript">
			var vm1 = new Vue({
				el: "#box",
				data: {
					Vuetext: "",
					datalist: ["abcd", "bab", "cqc", "ddc", "eace"]
				},
				computed: {
					computedlist() {
						return this.datalist.filter(item => item.includes(this.Vuetext))
					}
				}
			})
		</script>
    <!-- 计算属性-改造案例2 -->
    <body>
    	<!-- 购物车 -->
    			<div class="shoppingCart">
    				<input type="checkbox" v-model="isAll" @change="allChecked">全选
    				<ul>
    					<li v-for="(item,index) in datalist" :key="item.id">
    						<input type="checkbox" v-model="checklist" :value="item" @change="itemChecked">
    						<img :src="item.pic">
    						<div>
    							<div>{{item.name}}</div>
    							<div style="color: red;">￥ {{item.price}}</div>
    						</div>
    						<div>
    							<button @click="item.number--" :disabled="item.number===1">-</button>
    							<span>{{item.number}}</span>
    							<button @click="item.number++" :disabled="item.number===item.limit">+</button>
    						</div>
    						<div>
    							<button @click="delProduct(index,item.id)">删除</button>
    						</div>
    					</li>
    				</ul>
    				<div>总金额：{{computedSumPrice}}</div>
    				{{checklist}}
    			</div>
    			<script src="https://unpkg.com/vue@next"></script>
    			<script type="text/javascript">
    				var obj = {
    					data() {
    						return {
    							isAll:false,
    							datalist: [{
    									name: "商品1",
    									price: 10,
    									number: 1,
    									id: 1,
    									limit: 5, //限购
    									pic: "../../img/2.jpg"
    								},
    								{
    									name: "商品2",
    									price: 130,
    									number: 1,
    									id: 2,
    									limit: 5, //限购
    									pic: '../../img/3.png'
    								},
    								{
    									name: "商品3",
    									price: 1467,
    									number: 1,
    									id: 3,
    									limit: 5, //限购
    									pic: "../../img/4.jpg"
    								}
    							],
    							checklist: []
    						}
    					},
    					methods: {
    						allChecked(){//全选
    							if(this.isAll){
    								this.checklist=this.datalist
    							}else{
    								this.checklist=[]
    							}
    						},
    						itemChecked(){//单选时
    							if(this.checklist.length===this.datalist.length){
    								this.isAll=true
    							}else{
    								this.isAll=false
    							}
    						},
    						// sumPrice() {//总金额
    						// 	var total = 0
    						// 	this.checklist.forEach(item => {
    						// 		total += item.price * item.number
    						// 	})
    						// 	return total
    						// },
    						delProduct(index,id) {//删除
    							this.datalist.splice(index,1)//从第几个索引值开始删除
    							this.checklist=this.checklist.filter(item=>item.id!==id)//filter()过滤 删除
    							//同步一哈状态
    							this.itemChecked()
    						}
    					},
						//或使用计算属性
						computed:{
							computedSumPrice(){
								var total = 0
								this.checklist.forEach(item => {
									total += item.price * item.number
								})
								return total
							}
						}
    				}
    				Vue.createApp(obj).mount(".shoppingCart")
    			</script>
    		
    </body>
    
    
    
    <!-- watch----监测变动 -->
		<!-- 第一种模糊查询 -->
		<!-- input change事件区别:change失去焦点才触发 ，v-model监听-->
		<div class="box">

			<input type="text" v-model="Vuetext">
			<ul>
				<li v-for="data in datalist" :key="data">
					{{data}}
				</li>
			</ul>
		</div>
		<script type="text/javascript">
			new Vue({
				el: ".box",
				data: {
					Vuetext: "",
					datalist: ["abcd", "bab", "cqc", "ddc", "eace"],
					originlist: ["abcd", "bab", "cqc", "ddc", "eace"]
				},
				//监听
				watch: {
					Vuetext(newval) {
						console.log("改变了", newval)
						//延迟
						setTimeout(() => {
							this.datalist = this.originlist.filter(item => item.includes(newval))
						}, 1000)
					}
				}

			})
			// 方法、 计算属性、 watch区别？
			// data => 状态， 被拦截
			// 1、 方法， 事件绑定， 逻辑计算， 可省return， no缓存。
			// 2、 计算属性， 重视结果， 解决模板过重问题， 必须return， 只求结果， 有缓存， 同步。
			// 3、 watch， 重视过程， 监听一个值的改变， 不用返回值， 异步同步。
		</script>
    
    
    
    <!-- fetch-get -->
		<div class="box">
			<button type="button" @click="fetchClick">fetch</button>
		</div>
		<script type="text/javascript">
			new Vue({
				el: ".box",
				data: {},
				methods:{
					fetchClick(){
						fetch("http://127.0.0.1:8848/HBXproject/QF/json/test.json")//http://127.0.0.1:8848/HBXproject/QF/
						.then(res=>res.json())//转化，否则只能拿到状态码和响应头
						.then(res=>{
							console.log(res)
						})
						.catch(err=>{
							console.log(err)
						})
						    
					}
				}

			})
			
		</script>

    
    
    <!-- fetch-get/post -->
		<div class="box">
			<button type="button" @click="fetchClick">fetch</button>
		</div>
		<script type="text/javascript">
			new Vue({
				el: ".box",
				data: {},
				methods: {
					fetchClick() {
						//fetch-get
						fetch(
							"http://127.0.0.1:8848/HBXproject/QF/json/test.json") //http://127.0.0.1:8848/HBXproject/QF/
							.then(res => res.json()) //转化，否则只能拿到状态码和响应头
							.then(res => {
								console.log(res)
							})
							.catch(err => {
								console.log(err)
							})

						//fetch-post-1     
						fetch("http://127.0.0.1:8848/HBXproject/QF/json/test.json", {
							method: "post",
							headers: {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							body: "name=topsky&age=888"
						}).then(res => res.json()).then(res => {
							console.log(res)
						});

						//fetch-post-2
						fetch("http://127.0.0.1:8848/HBXproject/QF/json/test.json", {
							method: "post",
							headers: {
								"Content-Type": "application/json"
							},
							body: JSON.stringify({
								name: "topsky",
								age: 888
							})
						}).then(res => res.json()).then(res => {
							console.log(res)
						});


						//fetch应用
						//"m.maizuo.com/v5/#/films/nowPlaying"
						fetch(
							"http://127.0.0.1:8848/HBXproject/QF/json/maizuofilm.json") //http://127.0.0.1:8848/HBXproject/QF/
							.then(res => res.json()) //转化，否则只能拿到状态码和响应头
							.then(res => {
								console.log(res)
							})
							.catch(err => {
								console.log(err)
							})
					}
				}

			})
		</script>
		
    
    
    
    <!-- fetch-get/post -->
		<div class="box">
			<button type="button" @click="fetchClick">fetch</button>
		</div>
		<script type="text/javascript">
			new Vue({
				el: ".box",
				data: {},
				methods: {
					fetchClick() {
						//fetch-get
						fetch(
							"http://127.0.0.1:8848/HBXproject/QF/json/test.json") //http://127.0.0.1:8848/HBXproject/QF/
							.then(res => res.json()) //转化，否则只能拿到状态码和响应头
							.then(res => {
								console.log(res)
							})
							.catch(err => {
								console.log(err)
							})

						//fetch-post-1     
						fetch("http://127.0.0.1:8848/HBXproject/QF/json/test.json", {
							method: "post",
							headers: {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							body: "name=topsky&age=888"
						}).then(res => res.json()).then(res => {
							console.log(res)
						});

						//fetch-post-2
						fetch("http://127.0.0.1:8848/HBXproject/QF/json/test.json", {
							method: "post",
							headers: {
								"Content-Type": "application/json"
							},
							body: JSON.stringify({
								name: "topsky",
								age: 888
							})
						}).then(res => res.json()).then(res => {
							console.log(res)
						});


						//fetch应用
						//"m.maizuo.com/v5/#/films/nowPlaying"
						fetch(
							"http://127.0.0.1:8848/HBXproject/QF/json/maizuofilm.json") //http://127.0.0.1:8848/HBXproject/QF/
							.then(res => res.json()) //转化，否则只能拿到状态码和响应头
							.then(res => {
								console.log(res)
							})
							.catch(err => {
								console.log(err)
							})
					}
				}

			})
		</script>
		
		
		<!-- axios -->
		<!-- <script src="../../axios/axios.js"></script> -->
		<div id="axios">
			<button @click="handleAxios">ajax - axios</button>
			<ul>
				<li v-for="(data,index) in datalist" :key="index">
					<img :src="data.imgUrl" >
					<div>{{data.name}}</div>
					<!-- <div>评分：{{data.grade}}</div> -->
				</li>
			</ul>
		</div>
		<script type="text/javascript">
		var	as=new Vue({
				el:"#axios",
				data:{
					datalist:[]
				},
				methods:{
					handleAxios(){
						//axios.get
						//axios.get("addresss?name=topsky&age=180")
						axios.get("http://127.0.0.1:8848/HBXproject/QF/json/maizuofilm.json").then(res=>{console.log(res.data)
						    this.datalist=res.data
						}).catch(err=>{ console.log(err) })
						
						//axios.post
						// axios.post("address","name=topsky&age=180")//(1)
						// axios.post("address",{name:"topsky"&age:180})//(2)
					}
				}
			})
		</script>

        <!-- 过滤器 ,vue@next不支持-->
		<div id="ajax">
			<button @click="handleAjax">ajax</button>
			<ul>
				<li v-for="item in datalist" :key="item.Id">
					<img :src="item.img | imgFilter | imgFilter2" >
					{{item.nm}}
				</li>
			</ul>
		</div>
		<script type="text/javascript">
		Vue.filter("imgFilter1",(url)=>{
			return url.replace("w.h/","")//+'@1l_1e_1c_128w_180h' or filter2
		})
		Vue.filter("imgFilter2",(url)=>{
			return url+'@1l_1e_1c_128w_180h'
		})
		var	aj=new Vue({
				el:"#ajax",
				data:{
					datalist:[]
				},
				methods:{
					handleAjax(){
						axios.get("http://127.0.0.1:8848/HBXproject/QF/json/xx.json").then(res=>{console.log(res.data.movelist)
						    this.datalist=res.data.movelist
						}).catch(err=>{ console.log(err) })
					}
				}
			})
		</script>
    
    
    
    <!-- 组件化 -->
		<!-- 扩展HTML元素，封装可重用的代码 -->
		<!-- Vue自定义标签<swiper>includs dom,css,js</swiper> -->
		<div class="component" style="height: 200px; background: deepskyblue;">
			<!-- {{mytext}} 不能访问组件内部，所以{{mytext}}此处错误-->
			<!-- 自定义标签 -->
			<navbar></navbar>
			<!-- <top-navbar></top-navbar>
			<swiper></swiper> -->
			组件
			<component-Child></component-Child>
		</div>
		<script type="text/javascript">
			//定义全局的组件
			Vue.component("navbar", {
				//dom、css、js
				template: `<div style="background:red;border:2px black solid;">
				    <button @click="handleLeft">left</button>
					猫眼电影--{{mytext}}<!--变量等只能放template里面-->
					<button @click="handleRight">rigt</button>
					<component-Child></component-Child>
					<navbar-Child></navbar-Child>
				</div>`,
				methods: {
					handleLeft() {
						console.log("left")
					},
					handleRight() {
						console.log("right")
					},
				},
				computed: {},
				watch: {},
				data() { //data必须是函数
					return {
						mytext: "Topsky"
					}
				},
				// 定义局部组件
				components: {
					"navbarChild": {
						template: `<div>navbarChild局部</div>`
					}
				}
			})
			Vue.component("componentChild", {
				template: `<div style="background:yellow">componentChild全局</div>`
			})

			//根组件
			new Vue({
				el: ".component"
			})
			// 注意：
			// 	1、命名：js驼峰，html连接符“-”
			// 	2、dom片段，没有代码提示和高亮--Vue单文件组件解决
			// 	3、css只有行内样式--Vue单文件组件解决
			// 	4、template只能包含一个根节点<div><div></div></div>不能有兄弟节点
			// 	5、组件是孤岛，无法直接访问外面的组件的状态或方法--间接的组件通信来交流
			// 	6、自定义组件data必须是一个函数
			// 	7、所有自定义组件都在一起，乱--Vue单文件组件解决
		</script>
    
    
    
    <!--父传子、子传父 navbar-->
		<div id="box">
			<div style="background-color: yellow;">根组件标题</div>
			<navbar myprops="电影" :myleft="false" :myparent="parent">父</navbar>
			<navbar myprops="影院" :myright="false" :myparent="parent">父</navbar>
		</div>
		<script type="text/javascript">
			Vue.component("navbar", {
				
				//props: ["myprops", "myleft", "myright"],//接受属性myprops，this.myprops
				
				// props:{
				// 	myprops:String,
				// 	myright:Boolean
				// },//接受属性，属性验证
				
				props:{
					myprops:{
						type:String,
						default:""
					},
					myright:{
						type:Boolean,
						default:true
					},
					myparent:{
						type:String,
						default:""
					}
				},//接受属性，属性验证，默认属性
				template: `<div>
			       <button >left</button>
			       <span>子--{{myprops}}--{{myparent}}</span>
			       <button v-show="myright">right</button>
		        </div>`
			})
			//根组件
			new Vue({
				el:"#box",
				data:{
					parent:"I'm u parent"
				}
			})
		</script>
    
    
    
    
    <!-- 父传子靠属性，子传父靠事件，父子通信实现 -->
		<div id="box" style="background-color: red;">

			<navbar @myevent="handleEvent"></navbar>

			<sidebar v-show="isShow"></sidebar>

		</div>
		<script type="text/javascript">
			//封装组件navbar
			Vue.component("navbar", {
				template: `<div>
				    <button @click="showClick()">导航栏</button>
			    </div>`,
				methods:{
					showClick(){//子（子传父）
						this.$emit("myevent", 1000)//分发给父，触发handleEvent
					}
				}

			})

			//封装组件sidebar
			Vue.component("sidebar", {
				template: `<div style="background-color: yellow;">
				<ul>
					<li>1</li>
					<li>2</li>
					<li>3</li>
					<li>4</li>
				</ul>
			</div>`
			})
			//根组件
			new Vue({
				el: "#box",
				data: {
					isShow: false
				},
				methods:{//父
					handleEvent(data){//navbar相对于父组件#box的事件（子传父）
						console.log("子传父", data)
						this.isShow=!this.isShow
					}
				}
			})
		</script>
    
    
    
    
    <!-- 根作为中间人组件，实现兄弟间的通信 -->
		<div id="box">
			<button @click="handleAjax">ajax</button>
			<film-item v-for="(item,index) in datalist" :key="item.bannerId" :mydata="item" @event="handleEvent"></film-item>
			<film-detail :film-data="filmdata"></film-detail>
		</div>
		<script type="text/javascript">
			//封装组件1
			Vue.component("filmItem",{
				props:["mydata"],
				template:`
				    <div class="item">
						<img :src="mydata.imgUrl">
						{{mydata.name}}
						<button @click="handleDetail">详情</button>
					</div>
				`,
				methods:{
					handleDetail(){
						//console.log("zi1",this.mydata.bannerId)
						this.$emit("event",this.mydata.bannerId)//子传父给handleEvent()
					}
				}
			})
			//封装组件2
			Vue.component("filmDetail",{
				props:["filmData"],//接受:film-data="filmdata"父传子2
				template:`
				    <div class="filmDetailInfo" style="background:yellow;">
					this.mydata.bannerId->fimldata->:film-data:    {{filmData}}
					</div>
				`
			})
			new Vue({
				el: "#box",
				data:{
					datalist:[],
					filmdata:""
				},
				methods:{
					handleAjax(){
						fetch("http://127.0.0.1:8848/HBXproject/QF/json/maizuo.json").then(res=>res.json())
						.then(res=>{ 
							console.log(res.data)
							this.datalist=res.data
						})
					},
					handleEvent(childdata){
						console.log("Fu",childdata)
						this.filmdata=childdata
					}
				}
			})
		</script>

    
    
    
    <!-- BUS中央事件总线，子代、叔侄通信 -->
		<!-- var bus=new Vue() -->
				<div id="BUS">
					<button @click="handleAjax">ajax</button>
					<film-item v-for="(item,index) in datalist" :key="item.bannerId" :mydata="item"></film-item>
					<film-detail ></film-detail>
				</div>
				<script type="text/javascript">
				    var bus=new Vue()
					//bus.$on监听
					//bus.$emit触发
				    
					//封装组件1
					Vue.component("filmItem",{
						props:["mydata"],
						template:`
						    <div class="item">
								<img :src="mydata.imgUrl">
								{{mydata.name}}
								<button @click="handleDetail">详情-发布者</button>
							</div>
						`,
						methods:{
							handleDetail(){
								console.log("发布者-send",this.mydata.bannerId)
								bus.$emit("Topsky",this.mydata.bannerId)//触发Topsky函数
							}
						}
					})
					//封装组件2
					Vue.component("filmDetail",{
						// 组件刚创建好就开始订阅
						data(){
							return {
								info:""
							}
						},
						//生命周期
						mounted() {
							bus.$on("Topsky",(data)=>{
								console.log("订阅者-get", data)
								this.info=data
							})
						},
						template:`
						    <div class="filmDetailInfo" style="background:yellow;">
							订阅者-get: {{info}}
							</div>
						`
					})
					//根
					new Vue({
						el: "#BUS",
						data:{
							datalist:[],
						},
						methods:{
							handleAjax(){
								fetch("http://127.0.0.1:8848/HBXproject/QF/json/maizuo.json").then(res=>res.json())
								.then(res=>{
									this.datalist=res.data
								})
							},
						}
					})
				</script>
		
    
    
	
    <!-- ref组件通信 -->
		<div id="ref">
			<input type="text" ref="mytxt" />
			<input type="password" ref="mypwd" />
			<button @click="handleAdd">add</button>
			<child ref="mychild"></child>
		</div>
		<script>
		    Vue.component("child",{
				data(){
					return{
						childName:'Topsky'
					}
				},
				template:`
				   <div>
				       childName--{{childName}}
				   </div>
				`
			})
		    new Vue({
				el:"#ref",
				methods:{
					handleAdd(){
						//console.log(this.$refs.mytxt.value,this.$refs.mypwd)
						console.log("根组件获取子组件数据",this.$refs.mychild.childName)
						this.$refs.mychild.childName="kali"//暂时-修改子组件的数据
					}
				}
			})
		</script>
    
    
    <!-- v-once缓存，执行一次，模板不更新 -->
		<script type="text/javascript">
			Vue.component("vOnce",{
				template:`
				    <div v-once>
					    <h1>vOnce</h1>
						... a lot of static content ...
					</div>
				`
			})
		</script>
    
    
    
    
    <!-- 动态组件 -->
		<div id="box">
			<!-- 第一种-固定式 -->
			<!-- <home v-show=" which==='home' "></home>
			<list v-show=" which==='list' "></list>
			<shopcar v-show=" which==='shopcar' "></shopcar> -->
			
			<!-- 第二种-动态组件,keep-alive当切换到列表等时，search输入框内保留有你输入数据，保留后台 -->
			<keep-alive>
				<component :is="which"></component>
			</keep-alive>
			
			<footer>
				<ul> 
					<li @click=" which='home' ">首页</li>
					<li @click=" which='list' ">列表</li>
					<li @click=" which='shopcar' ">购物车</li>
				</ul>
			</footer>
		</div>
		<script type="text/javascript">
			Vue.component("home",{
				template:`
				    <div>
					    home
						<input type="search" />
					</div>
				`
			})
			Vue.component("list",{
				template:`
				    <div>
					    list
					</div>
				`
			})
			Vue.component("shopcar",{
				template:`
				    <div>
					    shopcar
					</div>
				`
			})
			
			new Vue({
				el:"#box",
				data:{
					which:"home"
				}
			})
		</script>
    
    
    
    
    
    <!-- 旧新-slot 插槽，扩展组件能力，提高代码复用性 -->
		<div id="box">
			<!-- old-组件child会将<div>aaaa</div><div>bbbb</div>按slot=？丢到插槽<slot></slot>中执行 -->
			<child>
				<div slot="a">aaaa</div>
				<div slot="b">bbbb</div>
				<div>默认插槽</div>
			</child>
            
            <!-- new-组件child会将<div>aaaa</div><div>bbbb</div>按v-slot:a、#?丢到插槽<slot></slot>中执行 -->
			<child>
				<template v-slot:a>
					<div >aaaa</div>
				</template>
				
				<template #b>
					<div >bbbb</div>
				</template>
				<div>默认插槽</div>
			</child>
			
		</div>
		<script type="text/javascript">
			Vue.component("child",{
				template:`
				    <div>
					   child
					   <slot name="a"></slot>
					   <slot name="b"></slot>
					   <slot></slot>
					</div>
				`
			})
			
			new Vue({
				el:"#box"
			})
		</script>
    
    
    
    <!-- slot -->
		<div id="box">
			<!-- 自定义组件之间可以不通信 -->
			<navbar>
				<button @click="isShow=!isShow">呼出侧边栏</button>
			</navbar>
			
			<sidebar v-show="isShow">侧边栏</sidebar>
			
		</div>
		<script type="text/javascript">
			Vue.component("navbar",{
				template:`
				    <div>
					   navbar-
					   <slot></slot>
					</div>
				`
			})
			Vue.component("sidebar",{
				template:`
				    <div style="background:yellow;width:100px;height:400px; ">
					   sidebar
					</div>
				`
			})
			
			new Vue({
				el:"#box",
				data:{
					isShow:false
				}
			})
		</script>
    
    
    
    
    <!-- slot 侧边栏抽屉、过渡效果-->
    <style>
        .Topsky-enter-active{
				animation: move 1.5s;
			}
			.Topsky-leave-active{
				animation: move 1.5s reverse;/* reverse逆向执行 */
			}
			
			@keyframes move{/* 关键帧 */
				0% {
					opacity: 0;
					transform: translateX(100px);
				}
				100% {
					opacity: 1;
					transform: translateX(0px);
				}
			}
    </style>
		<div id="box">
			<!-- 自定义组件之间可以不通信 -->
			<navbar>
				<button @click="isShow=!isShow">呼出侧边栏</button>
			</navbar>
			
			<!-- 第一种-过度效果执行方案 -->
			<!-- <sidebar v-show="isShow" class="sidebar-active sidebar-leave">侧边栏</sidebar> -->
			
			<!-- 第二种-Vue的过度效果执行方案 -->
			<!-- <transition  enter-active-class="Topsky-enter-active" leave-active-class="Topsky-leave-active">
				<sidebar v-show="isShow">侧边栏</sidebar>
			</transition> -->
			 
			 <!-- 第二种之出现sidebar就执行过度效果 -->
			<transition name="Topsky" appear>
				<sidebar v-show="isShow">
					<div>侧边栏s</div>
				</sidebar>
			</transition>

			

		</div>
		<script type="text/javascript">
			Vue.component("navbar", {
				template: `
						    <div>
							   navbar-
							   <slot></slot>
							</div>
						`
			})
			Vue.component("sidebar", {
				template: `
						    <div style="background:yellow;width:100px;height:400px; ">
							   sidebar
							   <slot></slot>
							</div>
						`
			})

			new Vue({
				el: "#box",
				data: {
					isShow: true
				}
			})
		</script>
    
    
    <!-- 
		vue组件->生命周期？
		vue组件的->钩子函数？
		vue组件的生命周期钩子函数？
    -->
    
    
    
    <!-- swiper 静态、动态 swiper.com.cn 轮播组件-->
    
    
    <!--Vue3组件写法-->
    <div class="box">
			{{10+908}}
			{{text}}
			<input type="text" v-model="text">
			<navbar myname="aa">
				<div>111</div>
			</navbar>
		</div>
		<script src="https://unpkg.com/vue@next"></script>
		<script>
		//函数式Vue3
			var obj={
				data(){
					return{
						text:"Hi Vue3",
						myname:'A'
					}
				},
				methods:{
					
				},
				computed:{
					
				}
			}
			
			// Vue.createApp(obj)
			// .component("navbar",{
			// 	props:["myname"],
			// 	template:`
			// 	   <div>
			// 	       Vue3-navbar
			// 		   {{myname}}
			// 		   <slot></slot>
			// 	   </div>
			// 	`
			// })
			// .mount(".box")
			//or
			var app=Vue.createApp(obj)
			app.component("navbar",{
				props:["myname"],
				template:`
				   <div>
				       Vue3-navbar
					   {{myname}}
					   <slot></slot>
				   </div>
				`
			})
			app.mount(".box")
			
		</script>

    
     <!-- 指令的写法及应用 -->
		<div class="box">
			<div v-hello>111111111</div>
			<div v-hello=" 'yellow' ">222222222</div>
			<div v-hello="whichColor">333333333</div>
		</div>
		
		<script type="text/javascript">
		    //指令：为了获取DOM节点
			Vue.directive("hello", {
				//指令的生命周期
				inserted(el,binding) {
					//第一次插入到父节点中触发，不可修改whichColor的值
					console.log("inserted", el, binding)
					el.style.background="red"
					el.style.background=binding.value
				},
				update(el, binding){
					//可以在console修改whichColor的值
					console.log("update")
					el.style.background=binding.value
				}
			})
			new Vue({
				el: ".box",
				data:{
					whichColor:"skyblue",
					
				}
			})
		</script>
     
```

Vue-反向代理&别名



SPA

1、概念：单页面应用（SinglePage Web Application，SPA）

2、组成：一个外壳页面 和 多个页面片段组成

3、资源共用（css,js）:共用，只需在外壳部分加载

4、刷新方式：页面局部刷新或更改

5、url模式：http://xxx.com/#/pageone

6、用户体验：页面片段切换时间块，用户体验良好

7、转场动画：易实现

8、数据传递：易

9、搜索引擎优化(SEO)：需单独方案，难，不利SEO检索可用服务器端渲染(SSR)优化

10、适用范围：高要求的体验，追求界面流畅度的应用

11、开发成本：高，需借助专业的框架 

12、维护成本：容易维护



MPA

1、概念：单页面应用（MultiPage Web Application，MPA）

2、组成： 多个完整页面构成

3、资源共用（css,js）:不共用，每个页面都需要加载

4、刷新方式：整页刷新

5、url模式：http://xxx.com/#/pageone.html

6、用户体验：页面片段切换加载缓慢，流畅度不够，用户体验比较差

7、转场动画：无法实现

8、数据传递：依赖url传参、cookie、localStorage等

9、搜索引擎优化(SEO)：实现方法简易

10、适用范围：适用于追求高度支持搜索引擎的应用

11、开发成本：低，但页面重复代码多

12、维护成本：不容易维护



**vue-router**路由

安装：npm/cnpm i --save vue-router 

路由模式：1、hash路由==>location.hash 切换、window.onhashchange监听路径的切换

​                    2、history路由==>history.pushState 切换、window.onpopstate监听路径的切换



**路由懒加载**

定义：由于打包构建应用时，js包很大，影响页面加载。我们把不同路由对应的组件分割成不同的代码块，就可以加载局部组件，更加高效。

方法：vue的异步组件+webpack的代码分割功能

```js
// 第一步，可以将异步组件定义为返回一个Promise的工厂函数（该函数返回的Promise应该resolve组件本身）
const Foo=()=>{
    Promise.resolve({
        // 组件定义对象
    })
}

//局部适时导入
routes>Search: component: () => import ("@/views/Search.vue"), // use 箭头函数导入，实现（局部 ）懒加载，当加载该组件时才导入  
```

**rem回顾**

**#  window.devicePixelRatio（物理像素）\* iPhone6 widthpx（375px） = 750px**

**# widthpx=document.documentElement.clientwidth 设备宽度**

